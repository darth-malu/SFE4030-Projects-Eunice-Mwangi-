#+title: Test

Testing a project that combines a *GUI (PySide6)*, *network operations (=pytubefix=)*, and *external processes* =ffmpeg= requires a multi-faceted approach. You should focus on **Unit Testing** for isolated components and *Integration/End-to-End Testing* for the overall functionality, often using *Mocks* and *Fixtures* to handle external dependencies.

Here are the possible ways to implement test cases:

1. Unit Testing with =pytest= and =Mocks= üß™

Unit testing focuses on testing small, isolated parts of your code, like the methods within the `Worker` class, without involving the actual, slow, or side-effect-prone external dependencies (network, filesystem, $\text{ffmpeg}$).

-----

** A. Testing the `Worker` Class (Core Logic)

The `Worker` class contains the critical download and merge logic. You should mock its external dependencies.

  * **Mocking $\text{pytubefix}$ (`YouTube`):** Prevent actual network calls to YouTube.

      * **Test Case:** **Successful Download.** Mock `YouTube` to return streams, mock the `download` method to simulate a file being saved, and mock $\text{ffmpeg}$ to simulate a successful merge. Assert that the signals (`finished`, `message`, `progress`) are emitted correctly and that the cleanup occurs.
      * **Test Case:** **Invalid URL/Video Unavailable.** Mock the `YouTube` initialization to raise an exception (e.g., `pytubefix.exceptions.VideoUnavailable`) and assert that the `error` signal is emitted.
      * **Test Case:** **No Suitable Stream.** Mock `yt.streams.filter` to return empty lists for both video and audio, and assert the `error` signal is emitted with the correct message.

  * **Mocking $\text{subprocess}$ (`ffmpeg_merge`):** Prevent running the actual $\text{ffmpeg}$ command.

      * **Test Case:** **$\text{ffmpeg}$ Success.** Mock `subprocess.run` to succeed (return value with `check=True` passing) and assert the `finished` and `message` signals are emitted.
      * **Test Case:** **$\text{ffmpeg}$ Failure.** Mock `subprocess.run` to raise a `subprocess.CalledProcessError` (simulating a failed merge) or `FileNotFoundError` (simulating $\text{ffmpeg}$ not installed). Assert the `error` signal is emitted.

  * **Testing `on_progress_callback`:**

      * **Test Case:** **Progress Calculation.** Call `on_progress_callback` directly with controlled input values for `stream.filesize` and `bytes_remaining`. Assert that the `progress` signal emits the expected percentage (e.g., testing the $done \times 60 / total$ calculation).

-----

** B. Testing File System Utilities

The `Worker` and `MainApp` classes use file system operations (`path.expanduser`, `makedirs`, `shutil.rmtree`). Use Python's built-in `unittest.mock.patch` or `pytest-mock` to mock these functions, or use **`pyfakefs`** to create a fake, in-memory file system for reliable testing without touching the actual disk.

  * **Test Case:** **Directory Creation.** Test `makedirs(self.temp_yt_folder, exist_ok=True)` in `download_video` to ensure it runs without error.
  * **Test Case:** **Cleanup.** Test the `finally` block in `Worker.run` by ensuring `shutil.rmtree` is called for `self.temp_yt_folder` after a successful and a failed download.

-----

2. Integration / End-to-End (E2E) Testing with `pytest-qt` üñºÔ∏è

E2E testing is necessary to ensure the GUI (PySide6) correctly interacts with the worker threads and displays the right information.

  * **Use `pytest-qt` fixtures:**

      * Use the `qtbot` fixture to simulate user interaction (clicks, typing, pressing Enter) and wait for signals to be emitted.
      * Use the `qapp` fixture to ensure a `QApplication` instance is available for testing.

  * **Test Case:** **GUI Flow - Success.**

    1.  Instantiate `MainApp`.
    2.  Type a mock URL into `self.url_input`.
    3.  Simulate pressing **Enter** (`self.url_input.returnPressed.emit()`).
    4.  **Mock the `Worker`'s execution** (see Unit Testing section) to immediately emit the `message`, `progress`, and `finished` signals in a controlled sequence.
    5.  Assert the `self.progress_bar` is visible, its value updates, and then it hides.
    6.  Assert the placeholder text is updated with the "Downloading" message and then the "Downloaded" message.
    7.  Assert controls (`url_input`, `file_choose_btn`) are disabled during the mocked download and re-enabled afterward.

  * **Test Case:** **GUI Flow - Error.**

    1.  Follow steps 1-3 from the success case.
    2.  **Mock the `Worker`** to immediately emit the `error` signal.
    3.  Assert the placeholder text is updated with the error message and resets after a delay (this tests the `QTimer.singleShot` logic).
    4.  Assert controls are re-enabled.

  * **Test Case:** **File Chooser Interaction.**

    1.  Simulate a click on `self.file_choose_btn`.
    2.  **Mock `QFileDialog.getExistingDirectory`** to return a *new* folder path (e.g., `/tmp/new_download`).
    3.  Assert `self.current_download_folder` is updated.
    4.  Assert `self.download_path_label` text is updated to reflect the new path.

-----

## 3\. Recommended Implementation Structure

To make testing easier, you should separate the `Worker`'s core functionality into testable, synchronous functions that don't directly emit signals, and keep the signal handling in `Worker.run`.

1.  **Project Structure:**

    ```
    youtubr/
    ‚îú‚îÄ‚îÄ youtubr_app.py   # Your main code (MainApp, Worker, etc.)
    ‚îî‚îÄ‚îÄ tests/
        ‚îú‚îÄ‚îÄ conftest.py  # pytest fixtures for mocks, etc.
        ‚îî‚îÄ‚îÄ test_worker.py
        ‚îî‚îÄ‚îÄ test_gui.py
    ```

2.  **Use $\text{pytest}$ Fixtures:**
    Create fixtures to set up the environment, such as a mock `YouTube` object or a temporary test directory.

3.  **Refactor for Testability (Optional but Recommended):**
    Extract the core logic from `download_video` into a function that takes `YouTube` and stream objects as arguments and returns the paths, making it independent of `Worker`'s instance variables and signals.

Would you like me to provide a basic example of how to implement one of these test cases, such as mocking $\text{ffmpeg}$ in `test_worker.py`?
